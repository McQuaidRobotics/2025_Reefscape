package igknighters.commands;

import static edu.wpi.first.units.Units.Centimeter;
import static edu.wpi.first.units.Units.MetersPerSecond;

import edu.wpi.first.wpilibj.AddressableLEDBuffer;
import edu.wpi.first.wpilibj.AddressableLEDBufferView;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.LEDPattern;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.Commands;
import igknighters.subsystems.led.Led;

public class LEDCommands {
  public LEDCommands() {
    final AddressableLEDBuffer buffer = new AddressableLEDBuffer(36);
  }

  /**
   * Continuosly calls led.animate() at the index provided 0 = pwm1 1 = pwm2
   *
   * @param led
   * @param saturation
   * @param value
   * @param index
   * @param velocity
   * @return
   */
  public static Command rainbow(Led led, int saturation, int value, int index, double velocity) {
    final AddressableLEDBuffer buffer = new AddressableLEDBuffer(36);
    final LEDPattern rainbow = LEDPattern.rainbow(saturation, value);
    final LEDPattern scrollingRainbow =
        rainbow.scrollAtAbsoluteSpeed(MetersPerSecond.of(velocity), Centimeter.of(1.7));
    ;
    return Commands.run(
        () -> {
          scrollingRainbow.applyTo(buffer);
          led.animate(buffer, index);
        });
  }

  public static Command runSplit(
      Led led, int[] offsets, LEDPattern[] patterns, int[] lengths, int index) {
    final AddressableLEDBuffer buffer = new AddressableLEDBuffer(36);
    return Commands.runOnce(
        () -> {
          if (offsets.length != patterns.length) {
            DriverStation.reportError(
                "incorect lengths on offsets and patterns LED COMMANDS ", false);
          } else {
            for (int i = 0; i < patterns.length; i++) {
              AddressableLEDBufferView smallView =
                  buffer.createView(offsets[i], lengths[i] - offsets[i]);
              patterns[i].applyTo(smallView);
            }
            led.animate(buffer, 0);
          }
        });
  }
}
